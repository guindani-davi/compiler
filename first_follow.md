# Conjuntos First e Follow da Gramática Pascal Simplificado

## Análise da Gramática para Parser Descendente (LL)

### Conjuntos FIRST

```
FIRST(PROGRAMA) = {PROGRAM}
FIRST(CORPO) = {VAR, CONST, TYPE, FUNCTION, BEGIN}
FIRST(DECLARACOES) = {VAR, CONST, TYPE, FUNCTION, ε}

FIRST(DEF_CONST) = {CONST, ε}
FIRST(LISTA_CONST) = {ID}
FIRST(LISTA_CONST') = {ID, ε}
FIRST(CONSTANTE) = {ID}
FIRST(CONST_VALOR) = {STRING, ID, NUMBER}

FIRST(DEF_TIPOS) = {TYPE, ε}
FIRST(LISTA_TIPOS) = {ID}
FIRST(LISTA_TIPOS') = {SEMICOLON, ε}
FIRST(TIPO) = {ID}
FIRST(TIPO_DADO) = {INTEGER, REAL, ARRAY, RECORD, ID}

FIRST(DEF_VAR) = {VAR, ε}
FIRST(LISTA_VAR) = {ID}
FIRST(LISTA_VAR') = {SEMICOLON, ε}
FIRST(VARIAVEL) = {ID}
FIRST(LISTA_ID) = {ID}
FIRST(LISTA_ID') = {COMMA, ε}

FIRST(LISTA_FUNC) = {FUNCTION, ε}
FIRST(FUNCAO) = {FUNCTION}
FIRST(NOME_FUNCAO) = {FUNCTION}
FIRST(BLOCO_FUNCAO) = {VAR, BEGIN}
FIRST(BLOCO) = {BEGIN}

FIRST(LISTA_COM) = {ID, WHILE, IF, WRITE, READ, ε}
FIRST(COMANDO) = {ID, WHILE, IF, WRITE, READ}
FIRST(ELSE) = {ELSE, ε}

FIRST(VALOR) = {ID, NUMBER}
FIRST(VALOR') = {LPAREN, DOT, LBRACKET, PLUS, MINUS, TIMES, DIVIDE, ε}
FIRST(NOME) = {DOT, LBRACKET, ε}
FIRST(LISTA_NOME) = {LPAREN}
FIRST(LISTA_NOME') = {ID, NUMBER, COMMA, ε}

FIRST(EXP_LOGICA) = {ID, NUMBER}
FIRST(EXP_LOGICA') = {GT, LT, EQUALS, EXCLAMATION, ε}
FIRST(OP_LOGICO) = {GT, LT, EQUALS, EXCLAMATION}

FIRST(EXP_MAT) = {ID, NUMBER}
FIRST(EXP_MAT') = {PLUS, MINUS, TIMES, DIVIDE, ε}
FIRST(OP_MAT) = {PLUS, MINUS, TIMES, DIVIDE}

FIRST(NUMERO) = {NUMBER}
FIRST(ID) = {ID}
```

### Conjuntos FOLLOW

```
FOLLOW(PROGRAMA) = {$}
FOLLOW(CORPO) = {$}
FOLLOW(DECLARACOES) = {BEGIN}

FOLLOW(DEF_CONST) = {TYPE, VAR, FUNCTION, BEGIN}
FOLLOW(LISTA_CONST) = {TYPE, VAR, FUNCTION, BEGIN}
FOLLOW(LISTA_CONST') = {TYPE, VAR, FUNCTION, BEGIN}
FOLLOW(CONSTANTE) = {ID, TYPE, VAR, FUNCTION, BEGIN}
FOLLOW(CONST_VALOR) = {SEMICOLON}

FOLLOW(DEF_TIPOS) = {VAR, FUNCTION, BEGIN}
FOLLOW(LISTA_TIPOS) = {VAR, FUNCTION, BEGIN}
FOLLOW(LISTA_TIPOS') = {VAR, FUNCTION, BEGIN}
FOLLOW(TIPO) = {SEMICOLON, VAR, FUNCTION, BEGIN}
FOLLOW(TIPO_DADO) = {SEMICOLON, RPAREN, RBRACKET}

FOLLOW(DEF_VAR) = {FUNCTION, BEGIN}
FOLLOW(LISTA_VAR) = {FUNCTION, BEGIN, END}
FOLLOW(LISTA_VAR') = {FUNCTION, BEGIN, END}
FOLLOW(VARIAVEL) = {SEMICOLON, FUNCTION, BEGIN, END}
FOLLOW(LISTA_ID) = {COLON, RPAREN}
FOLLOW(LISTA_ID') = {COLON, RPAREN}

FOLLOW(LISTA_FUNC) = {BEGIN}
FOLLOW(FUNCAO) = {FUNCTION, BEGIN}
FOLLOW(NOME_FUNCAO) = {VAR, BEGIN}
FOLLOW(BLOCO_FUNCAO) = {FUNCTION, BEGIN}
FOLLOW(BLOCO) = {FUNCTION, BEGIN, ELSE, END}

FOLLOW(LISTA_COM) = {END}
FOLLOW(COMANDO) = {SEMICOLON, END}
FOLLOW(ELSE) = {END}

FOLLOW(VALOR) = {SEMICOLON, THEN, RPAREN, END}
FOLLOW(VALOR') = {SEMICOLON, THEN, RPAREN, END}
FOLLOW(NOME) = {ASSIGN, PLUS, MINUS, TIMES, DIVIDE, SEMICOLON, THEN, RPAREN, GT, LT, EQUALS, EXCLAMATION, END}
FOLLOW(LISTA_NOME) = {ASSIGN, PLUS, MINUS, TIMES, DIVIDE, SEMICOLON, THEN, RPAREN, GT, LT, EQUALS, EXCLAMATION, END}
FOLLOW(LISTA_NOME') = {RPAREN}

FOLLOW(EXP_LOGICA) = {THEN, BEGIN, RPAREN, SEMICOLON, END}
FOLLOW(EXP_LOGICA') = {THEN, BEGIN, RPAREN, SEMICOLON, END}
FOLLOW(OP_LOGICO) = {ID, NUMBER}

FOLLOW(EXP_MAT) = {GT, LT, EQUALS, EXCLAMATION, SEMICOLON, THEN, RPAREN, END}
FOLLOW(EXP_MAT') = {GT, LT, EQUALS, EXCLAMATION, SEMICOLON, THEN, RPAREN, END}
FOLLOW(OP_MAT) = {ID, NUMBER}

FOLLOW(NUMERO) = (vários contextos)
FOLLOW(ID) = (vários contextos)
```

### Observações Importantes

1. **Produções vazias (ε)**: A gramática possui várias produções vazias que devem ser tratadas verificando se o token atual está no FOLLOW do não-terminal.

2. **Conflitos potenciais**: 
   - VALOR e VALOR' precisam de análise cuidadosa
   - EXP_MAT e suas variantes compartilham símbolos iniciais

3. **Símbolos que iniciam comandos**:
   - ID, WHILE, IF, WRITE, READ

4. **Símbolos que iniciam expressões**:
   - ID, NUMBER (para expressões matemáticas)

5. **Tratamento de NOME**:
   - Pode ser vazio (ε)
   - Pode começar com DOT, LBRACKET
   - Usado para acesso a arrays e records
